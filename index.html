<!-- index.html -->
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>AnomicValue Charts</title>

  <!-- Roboto, plus pro -->
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
    rel="stylesheet"
  />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- CSS principal (cache-bust) -->
  <link rel="stylesheet" href="assets/style.css?v=6"/>
</head>
<body>
  <!-- Fond étoilé (optionnel) -->
  <canvas id="starfield"></canvas>

  <!-- HEADER -->
  <header class="fade-in-down">
    <div class="logo">
      <h1 class="logo-text">AnomicValue</h1>
    </div>
    <nav>
      <a href="#all" style="--i:0">All</a>
      <a href="#1d"  style="--i:1">1D</a>
      <a href="#1w"  style="--i:2">1W</a>
      <a href="#1m"  style="--i:3">1M</a>
      <a href="#1y"  style="--i:4">1Y</a>
    </nav>
  </header>

  <!-- MAIN -->
  <main>
    <div id="chartContainer" class="fade-in-up">
      <div id="loadingOverlay"><div class="spinner"></div></div>
      <canvas id="miniChart" width="200" height="50"></canvas>
      <div class="chart-controls">
        <button id="contrastBtn" aria-label="High Contrast"></button>
        <button id="fullscreenBtn" aria-label="Fullscreen"></button>
      </div>
      <canvas id="mainChart"></canvas>
    </div>
  </main>

  <!-- FOOTER -->
  <footer class="fade-in-up">
    <p>© 2025 AnomicValue. All rights reserved.</p>
  </footer>

  <script>
    // — STARFIELD ANIMÉ —
    const sf = document.getElementById('starfield'),
          sctx = sf.getContext('2d');
    let W, H;
    function resizeSF(){
      W = sf.width = innerWidth;
      H = sf.height = innerHeight;
    }
    window.addEventListener('resize', resizeSF);
    resizeSF();
    const stars = Array.from({length:200}, ()=>({
      x: Math.random()*W, y: Math.random()*H,
      r: 0.5 + Math.random()*1.0,
      a: 0.3 + Math.random()*0.7,
      dx: (Math.random()-0.5)*0.2,
      dy: (Math.random()-0.5)*0.2
    }));
    (function drawSF(){
      sctx.clearRect(0,0,W,H);
      for(const s of stars){
        s.x = (s.x + s.dx + W)%W;
        s.y = (s.y + s.dy + H)%H;
        sctx.beginPath();
        sctx.arc(s.x, s.y, s.r, 0, 2*Math.PI);
        sctx.fillStyle = `rgba(255,255,255,${s.a})`;
        sctx.fill();
      }
      requestAnimationFrame(drawSF);
    })();

    // — CHART.JS & LOGIQUE —
    const API_URL = 'https://script.google.com/macros/s/AKfycbzyaaDiRnXsKyx5-CwD_XFzPoCswdJoU_yfNLdmvanYPrgrUg_CjLDs8KlIHOLevsiSTg/exec';
    const mainCtx = document.getElementById('mainChart').getContext('2d'),
          miniCtx = document.getElementById('miniChart').getContext('2d');
    let mainChart, miniChart;

    async function fetchData(item){
      const res = await fetch(`${API_URL}?name=${encodeURIComponent(item)}`);
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const arr = await res.json();
      if(!Array.isArray(arr) || arr.length===0) throw new Error('No data');
      return arr;
    }

    async function loadChart(mode){
      const item = new URLSearchParams(location.search).get('item');
      if(!item) throw new Error('Missing ?item');
      const raw = await fetchData(item), grouped = {};
      for(const p of raw){
        const d = new Date(p.t*1000),
              lbl = String(d.getDate()).padStart(2,'0') + '/' +
                    String(d.getMonth()+1).padStart(2,'0');
        grouped[lbl] = p.v;
      }
      return { labels: Object.keys(grouped), values: Object.values(grouped) };
    }

    async function updateCharts(mode){
      document.getElementById('loadingOverlay').style.display = 'flex';
      try {
        const { labels, values } = await loadChart(mode);

        // Main chart
        if(mainChart){
          mainChart.data.labels = labels;
          mainChart.data.datasets[0].data = values;
          mainChart.update();
        } else {
          mainChart = new Chart(mainCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                label: 'Price',
                data: values,
                borderColor: '#66ccff',
                borderWidth: 3,
                backgroundColor: 'rgba(102,204,255,0.2)',
                tension: 0.3,
                pointRadius: 4,
                pointBackgroundColor: '#66ccff',
                pointBorderColor: '#ffffff',
                pointHoverRadius: 6
              }]
            },
            options: {
              responsive: true,
              interaction: { mode: 'nearest', intersect: true },
              plugins: {
                tooltip: { backgroundColor: '#000', titleColor: '#fff', bodyColor: '#fff' }
              },
              scales: {
                x: {
                  ticks: { color: '#eee' },
                  grid: { color: 'rgba(102,204,255,0.1)' }
                },
                y: {
                  ticks: {
                    color: '#eee',
                    callback: val => val.toLocaleString()
                  },
                  grid: { color: 'rgba(102,204,255,0.1)' }
                }
              }
            }
          });
        }

        // Mini sparkline
        if(miniChart){
          miniChart.data.labels = labels;
          miniChart.data.datasets[0].data = values;
          miniChart.update();
        } else {
          miniChart = new Chart(miniCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: values,
                borderColor: '#66ccff',
                borderWidth: 2,
                backgroundColor: 'transparent',
                tension: 0.3,
                pointRadius: 0
              }]
            },
            options: {
              responsive: true,
              plugins: { legend: { display: false } },
              scales: { x: { display: false }, y: { display: false } }
            }
          });
        }

      } catch(err) {
        console.error(err);
      } finally {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
    }

    document.querySelectorAll('nav a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        document.querySelectorAll('nav a').forEach(n => n.classList.remove('active'));
        a.classList.add('active');
        updateCharts(a.getAttribute('href').slice(1));
      });
    });

    window.addEventListener('DOMContentLoaded', () => {
      document.querySelector('nav a[href="#all"]').click();
    });

    document.getElementById('fullscreenBtn').onclick = () => {
      const el = document.getElementById('chartContainer');
      document.fullscreenElement ? document.exitFullscreen() : el.requestFullscreen();
    };
    document.getElementById('contrastBtn').onclick = () => {
      document.body.classList.toggle('high-contrast');
    };
  </script>
</body>
</html>
